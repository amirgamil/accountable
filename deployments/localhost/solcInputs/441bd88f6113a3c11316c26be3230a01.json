{
  "language": "Solidity",
  "sources": {
    "contracts/SharedDataStructures.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nlibrary SharedDataStructures {\n    struct Song {\n        string name;\n        //@notice, a song that has been minted into an NFT and stored on the Permaweb\n        //can no longer be added to it.\n        bool isMinted;\n        //@notice we keep a record of whether a song has been deleted or not\n        //to avoid to having to make an expensive write to adjust ids of existing songs.\n        //Instead, we set this boolean variable and delete notes.\n        //Any interaction with this song checks that this is not deleted\n        bool isDeleted;\n        //@notice array of characters that compromise the notes of the song. These\n        //get directly synthesized in the client by mapping them to actual notes.\n        //We uses bytes32 since each character in a song is of a fixed size, and\n        //this is more gas-optimized/cheaper\n        bytes32[] notes;\n        //@notice we use uint32 for struct packing\n        uint32 id;\n        uint32 bpm;\n    }\n}"
    },
    "contracts/SongStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport \"./SharedDataStructures.sol\";\n\ncontract SongStorage {\n    SharedDataStructures.Song[] public songs;\n    mapping (uint => address) public songToOwner; \n    mapping (address => int) public songOwnerCount; \n\n    //@notice event for when a new song is made\n    event NewSongCreated (string name, uint id, uint bpm);\n    event SongEdited (string name, uint id);\n    event SongDeleted(string name, uint id);\n    event SongMinted(string name, uint id);\n\n    function getAllSongs() view public returns (SharedDataStructures.Song[] memory) {\n        return songs;\n    }\n\n    function getSongFromId(uint id) view public returns (string memory, bool, bool, bytes32[] memory, uint32, uint32) {\n        require(id < songs.length);\n\n        SharedDataStructures.Song memory currSong = songs[id];\n\n        return (currSong.name, currSong.isMinted, currSong.isDeleted, currSong.notes, currSong.id, currSong.bpm);\n    }\n\n    function getNumberOfSongs() view public returns (uint32) {\n        return uint32(songs.length);\n    }\n\n    function _getSongOwner(uint id) view internal returns (address) {\n        return songToOwner[id];\n    }\n\n    modifier onlySongOwner(uint id) {\n        require(msg.sender == _getSongOwner(id));\n        _;\n    }\n\n    function _createSong(string memory _name, uint bpm) internal returns (uint) {\n        uint32 newId = getNumberOfSongs();\n        //@notice set limit on number of songs a person can create to prevent bots etc.\n        require(songOwnerCount[msg.sender] < 50);\n\n        songs.push(SharedDataStructures.Song({name: _name, isMinted: false, isDeleted: false, notes: new bytes32[](0), id: newId, bpm: uint32(bpm)}));\n\n        songToOwner[newId] = msg.sender;\n        //@notice we don't need to check if this exists due to Solidity's design of mappings\n        songOwnerCount[msg.sender]++;\n\n        emit NewSongCreated(_name, newId, bpm);\n\n        return newId; \n    }  \n\n    //@notice returns the id of the newly created song\n    function createNewSong(string memory _name, uint bpm) public returns (uint) {\n        return _createSong(_name, bpm);\n    }\n    \n    //@notice creates a new song like above, but also adds notes to the songs. This is done to optimize gas\n    //as opposed to calling createSong and then addNotes\n    function createNewSongWithNotes(string memory _name, uint bpm, bytes32[] memory newNotes) public returns (uint) {\n        uint id = _createSong(_name, bpm);\n\n        SharedDataStructures.Song storage newSong = songs[id];\n        newSong.notes = newNotes;\n\n        return id;\n    }\n\n    function _addNotesToSong(uint id, bytes32[] memory newNotes) internal returns (bytes32[] memory) {\n        //@notice ensure we're adding to a song that actually exists\n        require(id < songs.length);\n        //@notice for now, can only append 50 new notes at a time\n        require(newNotes.length < 50);\n\n        SharedDataStructures.Song storage currentSong = songs[id];\n\n        require(!currentSong.isDeleted);\n        require(!currentSong.isMinted);\n\n        for (uint i=0; i < newNotes.length; i++) {\n            currentSong.notes.push(newNotes[i]);\n        }\n\n        emit SongEdited(currentSong.name, id);\n\n        return currentSong.notes;\n\n    }\n\n    //@notice returns the full new song notes\n    function addNotes(uint id, bytes32[] memory newNotes) public returns (bytes32[] memory) {\n        return _addNotesToSong(id, newNotes);\n    }\n\n    function deleteSong(uint id) onlySongOwner(id) public {\n        require(id < songs.length);\n        require(!songs[id].isDeleted);\n\n        songs[id].isDeleted = true;\n        //@notice we delete the most expensive part of storing a song and bpm\n        //which will no longer be used\n        delete songs[id].notes;\n        delete songs[id].bpm;\n\n        emit SongDeleted(songs[id].name, id);\n    }\n\n    function mintSong(uint id) public {\n        require(id < songs.length);\n        require(!songs[id].isDeleted);\n\n        songs[id].isMinted = true;\n\n        emit SongMinted(songs[id].name, id);\n\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}